package backend.weka;

import weka.core.Attribute;
import weka.core.DenseInstance;
import weka.core.Instances;
import weka.core.converters.ArffLoader;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Field;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import common.PDFContainer;
import common.Scientific;
import common.Settings;
import backend.model.PDF;

public class LearningDataSet {

	/**
	 * Contains the attributes(structure) of a row(Instance).
	 * In our case one row/Instance means all the information of a single PDF file.
	 */
	private ArrayList<Attribute> atts = null;
	/**
	 * Contains all the information in multiple rows(Instance) by following the
	 * structure of attributes generated by the method generateFormat().
	 */
	private Instances data = null;
	/**
	 * This variable defines the 'true'/'false' boolean values as a nominal attribute.
	 * With this variable you can easily derive an attribute value from a boolean 
	 * variable.
	 */
	private ArrayList<String> attVals;

	private ArrayList<String> attVals2;

	private DateFormat generalDateFormat;

	private List<String> pdfWords = null;

	/**
	 * Initialize required essentials.
	 */
	private void init() {
		@SuppressWarnings("unused")
		DateFormat generalDateFormat = new SimpleDateFormat("yyyy-MM-dd");

		attVals = new ArrayList<String>();
		attVals.add("true");
		attVals.add("false");

		attVals2 = new ArrayList<String>();
		attVals2.add("1");
		attVals2.add("-1");
	}

	/**
	 * Generate the format(structure) of a single instance(row) by building up 
	 * the attributes from a class via reflection.
	 * <br /><br />
	 * <b>Handled types:</b> int, float, double, long, Date, boolean, Boolean,
	 * String, int[], float[], double[], long[], String[].
	 */
	@SuppressWarnings("unused")
	private void generateFormat() {
		atts = new ArrayList<Attribute>();

		// set up attributes
		//int n = PDFContainer.attrNo + Settings.selectedWordsNr;
		for(int i=0;i<PDFContainer.attrNo;++i){

			String attrName = PDFContainer.PDFAttrNames[i];
			int unusedSize = PDFContainer.unused.size();

			//Ignore predefined attributes
			if(PDFContainer.unused.contains(attrName)){
				continue;
			}

			if(i == PDFContainer.attrNo - 1){
				for(int ii = 0;ii < Settings.selectedWordsNr; ++ii){
					// - numeric
					if(pdfWords.size() <= ii){
						Settings.selectedWordsNr = ii;
						break;
						
					}
					atts.add(new Attribute(pdfWords.get(ii)));
				}
			}

			if(PDFContainer.PDFAttrTypes[i] == int.class || 
					PDFContainer.PDFAttrTypes[i] == float.class ||
					PDFContainer.PDFAttrTypes[i] == double.class ||
					PDFContainer.PDFAttrTypes[i] == long.class)
			{
				// - numeric
				atts.add(new Attribute(PDFContainer.PDFAttrNames[i]));
			}else if(PDFContainer.PDFAttrTypes[i] == Date.class){ 
				// - date
				atts.add(new Attribute(PDFContainer.PDFAttrNames[i], "yyyy-MM-dd"));
			}else if(PDFContainer.PDFAttrTypes[i] == boolean.class ||
					PDFContainer.PDFAttrTypes[i] == Boolean.class ){
				if(i==PDFContainer.attrNo-1){
					//the last attribute needs to be nominal
					atts.add(new Attribute(PDFContainer.PDFAttrNames[i], attVals2));
				}else{
					// - numeric now (not nominal) for multiple algorithm compability
					atts.add(new Attribute(PDFContainer.PDFAttrNames[i]));
				}

			}else if(PDFContainer.PDFAttrTypes[i] == String.class){
				// - string
				atts.add(new Attribute(PDFContainer.PDFAttrNames[i], 
						(ArrayList<String>) null));
			}else if(PDFContainer.PDFAttrTypes[i] == int[].class || 
					PDFContainer.PDFAttrTypes[i] == float[].class ||
					PDFContainer.PDFAttrTypes[i] == double[].class ||
					PDFContainer.PDFAttrTypes[i] == long[].class){
				// - relational
				ArrayList<Attribute> attsRel = new ArrayList<Attribute>();
				// -- numeric
				attsRel.add(new Attribute("Value"));
				Instances dataRel = new Instances(PDFContainer.PDFAttrNames[i], attsRel, 0);
				atts.add(new Attribute(PDFContainer.PDFAttrNames[i], dataRel, 0));
			}else if(PDFContainer.PDFAttrTypes[i] == String[].class){
				// - relational
				ArrayList<Attribute> attsRel = new ArrayList<Attribute>();

				// - string
				attsRel.add(new Attribute("Value", 
						(ArrayList<String>) null));
				Instances dataRel = new Instances(PDFContainer.PDFAttrNames[i], attsRel, 0);
				atts.add(new Attribute(PDFContainer.PDFAttrNames[i], dataRel, 0));

			}	  
		}

		DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd");
		Date date = new Date();

		// create Instances object
		data = new Instances("PDFCollection_"+dateFormat.format(date).toString(), atts, 0);
	}

	/**
	 * Building up the whole class from an ARFF Attribute 
	 * Relational File Format file.
	 * <br />
	 * The file has to represents informations about PDF files with the current 
	 * using attributes, but this has been not verified by the application yet.
	 * 
	 * @param path Contains the path of an .ARFF file.
	 */
	public LearningDataSet(String path) {
		ArffLoader loader = new ArffLoader();
		try {
			loader.setSource(new File(path));
			data = loader.getDataSet();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Building up the whole class from an .arff file(Attribute 
	 * Relational File Format) file.
	 * 
	 * The file has to represents informations about PDF files with the current 
	 * using attributes, but this has been not verified by the application yet.
	 * 
	 * @param path Contains the path of an .arff file.
	 */
	public void buildFromFile(String path) {
		ArffLoader loader = new ArffLoader();
		try {
			loader.setSource(new File(path));
			data = loader.getDataSet();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Initialize an empty instance of a class by setting up the structure(format) 
	 * of a single row(Instance) derived from the PDF class via reflection.
	 * 
	 * <b>Handled types:</b> int, float, double, long, Date, boolean, Boolean,
	 * String, int[], float[], double[], long[], String[].
	 */
	public LearningDataSet(List<String> pdfWords) {
		this.pdfWords = pdfWords;
		init();
		generateFormat();
	}

	/**
	 * Add a single PDF instance to the training set via reflection.
	 * 
	 * >Handled types:</b> int, float, double, long, Date, boolean, Boolean,
	 * String, int[], float[], double[], long[], String[].
	 * 
	 * @param pdf this is an instance of PDF class containing information 
	 * about a pdf file.
	 */
	public void addPDF(PDF pdf) {

		Field[] fields = PDF.class.getDeclaredFields();

		for(int j = 1; j< PDFContainer.attrNo; ++j){
			fields[j].setAccessible(true);
		}

		double[] vals = new double[data.numAttributes()];

		int index = 0;
		//int no = PDFContainer.attrNo + Settings.selectedWordsNr;

		for(int i = 0; i< PDFContainer.attrNo; ++i){

			String attrName = PDFContainer.PDFAttrNames[i];
			int unusedSize = PDFContainer.unused.size();

			//Ignore predefined attributes(except subtitles)
			if(PDFContainer.unused.contains(attrName) &&
					!PDFContainer.unused.get(unusedSize-1).equals(attrName)){
				continue;
			}

			if(i == PDFContainer.attrNo - 1){
				for(int ii = 0;ii<Settings.selectedWordsNr;++ii){	
					vals[index] = TFIDFforSelectedWords.TFIDFCalculation(pdf, pdfWords.get(ii));
					++index;
				}

			}

			if(PDFContainer.PDFAttrTypes[i] == int.class || 
					PDFContainer.PDFAttrTypes[i] == float.class ||
					PDFContainer.PDFAttrTypes[i] == double.class ||
					PDFContainer.PDFAttrTypes[i] == long.class)
			{
				// - numeric
				try {
					vals[index] = ((Number)fields[i].get(pdf)).doubleValue();
					++index;
				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				} catch (IllegalAccessException e) {
					e.printStackTrace();
				}
			}else if(PDFContainer.PDFAttrTypes[i] == Date.class){
				// - date
				try {
					try {
						vals[index] = data.attribute(index).parseDate(
								generalDateFormat.format(fields[i].get(pdf)).toString());
						++index;
					} catch (IllegalArgumentException e) {
						e.printStackTrace();
					} catch (IllegalAccessException e) {
						e.printStackTrace();
					}
				} catch (ParseException e) {
					e.printStackTrace();
				}
			}else if(PDFContainer.PDFAttrTypes[i] == boolean.class){
				// - numeric
				try {
					double boolVal = -1;
					if ((boolean) fields[i].get(pdf)){
						boolVal = 1;
					}
					vals[index] = boolVal;
					++index;
				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				} catch (IllegalAccessException e) {
					e.printStackTrace();
				}
			}else if(PDFContainer.PDFAttrTypes[i] == Boolean.class){
				try {
					if(i==PDFContainer.attrNo-1){
						//the last attribute must be nominal

						Boolean boolVal = (Boolean)fields[i].get(pdf);

						if (boolVal == null){
							boolVal = true;
						}

						vals[index] = attVals.indexOf(boolVal.toString());
						++index;
					}

				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				} catch (IllegalAccessException e) {
					e.printStackTrace();
				}
			}else if(PDFContainer.PDFAttrTypes[i] == String.class){
				// - string
				try {
					String strData = fields[i].get(pdf).toString();
					vals[index] = data.attribute(index).addStringValue(strData);
				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				} catch (IllegalAccessException e) {
					e.printStackTrace();
				}
				++index;
			}else if(PDFContainer.PDFAttrTypes[i] == int[].class || 
					PDFContainer.PDFAttrTypes[i] == float[].class ||
					PDFContainer.PDFAttrTypes[i] == double[].class ||
					PDFContainer.PDFAttrTypes[i] == long[].class){
				// - relational
				Instances dataRel = new Instances(data.attribute(index).relation(), 0);
				double elements[] = null;

				try {
					elements = (double[]) fields[i].get(pdf);
				} catch (IllegalArgumentException e1) {
					e1.printStackTrace();
				} catch (IllegalAccessException e1) {
					e1.printStackTrace();
				}

				// -- add instances
				double[] valsRel;

				int n = elements.length;

				for(int j = 0;j<n;++j){
					valsRel = new double[1];
					valsRel[0] = elements[j];
					dataRel.add(new DenseInstance(1.0, valsRel));
				}

				vals[index] = data.attribute(index).addRelation(dataRel);
				++index;
			}else if(PDFContainer.PDFAttrTypes[i] == String[].class){

				String elements[] = null;

				try {
					elements = (String[]) fields[i].get(pdf);
				} catch (IllegalArgumentException e1) {
					e1.printStackTrace();
				} catch (IllegalAccessException e1) {
					e1.printStackTrace();
				}	    

				// - relational
				Instances dataRel = new Instances(data.attribute(index).relation(), 0);

				// -- add instances
				double[] valsRel;

				int n = elements.length;

				for(int j = 0;j<n;++j){
					valsRel = new double[1];
					valsRel[0] = dataRel.attribute(0).addStringValue(elements[j]);
					dataRel.add(new DenseInstance(1.0, valsRel));
				}

				vals[index] = data.attribute(index).addRelation(dataRel);


				++index;
			}else if(PDFContainer.PDFAttrTypes[i] == Scientific.class){
				///
			}
		}

		// add
		data.add(new DenseInstance(1.0, vals));
	}

	/**
	 * Add multiple PDF instances to the training set via reflection.
	 *
	 * Handled types: int, float, double, long, Date, boolean, Boolean,
	 * String, int[], float[], double[], long[], String[].
	 * 
	 * @param pdf this is an array of PDF class containing information 
	 * about multiple PDF files.
	 */
	public void addAllPDF(PDF[] pdf){
		int n = pdf.length;
		for(int i = 0;i<n;++i){
			addPDF(pdf[i]);
		}
	}

	/**
	 * Add multiple PDF instances to the training set via reflection.
	 * 
	 * Handled types: int, float, double, long, Date, boolean, Boolean,
	 * String, int[], float[], double[], long[], String[].
	 * 
	 * @param pdf this is a list of PDF class containing information 
	 * about multiple PDF files.
	 */
	public void addAllPDF(List<PDF> pdfList){

		for (PDF pdf : pdfList) {
			addPDF(pdf);
		}
	}

	/**
	 * Writes the training set to the console in ARFF Attribute 
	 * Relational File Format format.
	 */
	public void write(){
		System.out.println(data);
	}

	/**
	 * Convert training set into String in ARFF Attribute 
	 * Relational File Format format.
	 */
	@Override
	public String toString(){
		return data.toString();
	}
	
	/** 
	 * 	  Get the number of rows(Instances) from the training set.	  
	 */
	public int getSize(){
		return data.size();
	}

	/**
	 * 
	 * Get the list of used words in calculating weights.
	 * 
	 */
	public List<String> getPdfWords() {
		if(pdfWords == null){
			System.out.println(data.attribute(PDFContainer.attrNo-
					PDFContainer.unused.size()));
		}
		return pdfWords;
	}

	/**
	 * 
	 * Get the actual training set as an Instances class instance.
	 * 
	 */
	public Instances getInstances(){
		return data;
	}
}
